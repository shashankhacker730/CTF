# [Lab] getproaddress

1. 這題直接先進去用 IDA pro 開啟檔案檢查並瀏覽，從 main_0 函數裡面可以直接看到滿完整的程式邏輯，就是可以看到 
    
        sub_1400113ED 會印出字串 “Give me flag: “
    
        → sub_1400111FE 會輸入字串 39 個 byte 長度
    
        → 接下來做一些事情猜測是比較輸入的字串正不正確
    
        → 錯誤的話會輸入”Wrong” ，正確的話會輸出 “Correct!!!”
    

![截圖 2022-11-10 下午8.52.57.png](%5BLab%5D%20getproaddress%207fd161d5cd0c4352bd3b7b6411aaf443/%25E6%2588%25AA%25E5%259C%2596_2022-11-10_%25E4%25B8%258B%25E5%258D%25888.52.57.png)

1. 於是可以直接去 trace if ( v10 == -1… 之後那一段程式碼，因為那邊會是比較輸入的字串正不正確的 code，這是我們主要分析的目標區域，但是這邊我只看得出來，for( j=0;j < 39;++j) 的這個 loop 會是將 39 個 chr 一個一個比對正不正確的 loop，其他看不太出來要做什麼事情，我的想法是，將 if ( v10 == -1 這一行 跟 for( j=0;j < 39;++j) 這兩個地方，去 x64dbg 設斷點，看可不可以看出比較多程式的行爲。

1. 接下來可以找出 if ( v10 == -1 這一行的 RVA 是 0x16249  ，for( j=0;j < 39;++j) 的 RVA 是 0x16294，於是我可以在 x64db中找到對應的位置並設下斷點，發現程式會執行到這附近，於是我把這邊每一行都再設斷點並觀察暫存器裡面的值。

![截圖 2022-11-10 下午9.52.17.png](%5BLab%5D%20getproaddress%207fd161d5cd0c4352bd3b7b6411aaf443/%25E6%2588%25AA%25E5%259C%2596_2022-11-10_%25E4%25B8%258B%25E5%258D%25889.52.17.png)

![截圖 2022-11-06 下午2.17.35.png](%5BLab%5D%20getproaddress%207fd161d5cd0c4352bd3b7b6411aaf443/%25E6%2588%25AA%25E5%259C%2596_2022-11-06_%25E4%25B8%258B%25E5%258D%25882.17.35.png)

1. 另外有先嘗試讓程式執行到 0x1A1D0的位址 ( 包含 “Correct!!!” 字串的那一行），方法是讓中間的一些跳轉不要跳轉，然後再讓程式繼續執行，但執行完後 Command line 不會出現 Correct 的字串而會直接結束，所以這種更改程式邏輯的方式應該是行不通。

1. 於是回過頭來繼續觀察暫存器裡面的值，如果我輸入的字串為 FLAG{00…00} 長度為 38 個字元的FLAG ，可以發現在 0x126EC的地方比較 RAX 及 RCX 的值然後決定要不要跳轉，並且會重複執行五次，因此可以確定這一段程式碼是在做字串比對，只是會將字串都做過加密，因為我輸入的字串前五個字元是 ”FLAG{“ 這一定會跟最後的 FLAG 吻合。

![截圖 2022-11-10 下午10.03.29.png](%5BLab%5D%20getproaddress%207fd161d5cd0c4352bd3b7b6411aaf443/%25E6%2588%25AA%25E5%259C%2596_2022-11-10_%25E4%25B8%258B%25E5%258D%258810.03.29.png)

![截圖 2022-11-10 下午10.03.34.png](%5BLab%5D%20getproaddress%207fd161d5cd0c4352bd3b7b6411aaf443/%25E6%2588%25AA%25E5%259C%2596_2022-11-10_%25E4%25B8%258B%25E5%258D%258810.03.34.png)

1. 接下來回去重新看 IDA Pro 的反編譯程式碼，在 loop 迴圈裡面有個 if 的判斷，這邊看起來只要比對到的一個字元不等於，就會 goto LABEL_11 然後就跳到 “Wrong”，於是可以推斷這邊只要看懂 v9 跟 v8 還有 byte_14001E000 的分別是什麼，並且讓它們等於，就可以不要跳到 “Wrong”，而是比對完 39 個字元後不會跳轉而進入 ”Correct!!!”

![截圖 2022-11-10 下午10.07.04.png](%5BLab%5D%20getproaddress%207fd161d5cd0c4352bd3b7b6411aaf443/%25E6%2588%25AA%25E5%259C%2596_2022-11-10_%25E4%25B8%258B%25E5%258D%258810.07.04.png)

![截圖 2022-11-10 下午10.09.47.png](%5BLab%5D%20getproaddress%207fd161d5cd0c4352bd3b7b6411aaf443/%25E6%2588%25AA%25E5%259C%2596_2022-11-10_%25E4%25B8%258B%25E5%258D%258810.09.47.png)

1. 而 v9 可以從 sub_1400111FE 這格函數可以看到是 input 的字串，v8 看不出來是什麼，看起來就是一段字串會跟輸入的字串做 XOR，然後這兩個 xor 的結過不能等於 byte_14001E000，推測byte_14001E000 它就是 enc_flag。因此，這邊思考邏輯是這樣
    
                  ⇒ 輸入的字串 xor v8 = enc_flag 
                  ⇒ 就可以進入 puts(”Correct!!!”)
                  ⇒ enc_flag xor v8 = flag 
                  ⇒ 找出 enc_flag 及 v8 的值
    

![截圖 2022-11-10 下午10.12.05.png](%5BLab%5D%20getproaddress%207fd161d5cd0c4352bd3b7b6411aaf443/%25E6%2588%25AA%25E5%259C%2596_2022-11-10_%25E4%25B8%258B%25E5%258D%258810.12.05.png)

![截圖 2022-11-10 下午10.07.04.png](%5BLab%5D%20getproaddress%207fd161d5cd0c4352bd3b7b6411aaf443/%25E6%2588%25AA%25E5%259C%2596_2022-11-10_%25E4%25B8%258B%25E5%258D%258810.07.04.png)

1. v8 的值可以在 0x14FBA2 得地方找到，enc flag 可以在 0x1E000 的記憶體位址找到( 但中間會夾雜 00 的 byte 要自己清除）。

![截圖 2022-11-10 下午10.25.30.png](%5BLab%5D%20getproaddress%207fd161d5cd0c4352bd3b7b6411aaf443/%25E6%2588%25AA%25E5%259C%2596_2022-11-10_%25E4%25B8%258B%25E5%258D%258810.25.30.png)

![截圖 2022-11-10 下午10.29.48.png](%5BLab%5D%20getproaddress%207fd161d5cd0c4352bd3b7b6411aaf443/%25E6%2588%25AA%25E5%259C%2596_2022-11-10_%25E4%25B8%258B%25E5%258D%258810.29.48.png)

1. 得到這兩個值之後，做 XOR 就可以直接得 FLAG{Just_a_customized_GetProcAddress!}

```python
enc_flag = bytearray.fromhex('122428345B3A071C132D00324316121A01021D5A07017F35101A701B0143052B3752081C174453')
v8 = bytearray.fromhex('546869732070726F6772616D2063616E6E6F742062652072756E20696E20444F53206D6F64652E')
FLAG=''
for i in range(len(enc_flag)):
    FLAG += str(chr(enc_flag[i]^v8[i]))
print(FLAG)
```